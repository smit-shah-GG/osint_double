---
phase: 03-planning-orchestration
plan: 01
type: execute
---

<objective>
Implement the core Planning & Orchestration Agent using LangGraph StateGraph with adaptive routing and objective decomposition.

Purpose: Create the intelligent coordinator that breaks down objectives and dynamically routes to agents based on discoveries.
Output: Working PlanningOrchestrator class with state management and adaptive routing capabilities.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3-planning-orchestration/03-RESEARCH.md
@.planning/phases/3-planning-orchestration/03-CONTEXT.md
@.planning/phases/2-base-agent-architecture/02-04-SUMMARY.md
@osint_system/orchestration/coordinator.py
@osint_system/agents/base_agent.py
@osint_system/agents/registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state schemas and Planning Agent foundation</name>
  <files>osint_system/orchestration/state_schemas.py, osint_system/agents/planning_agent.py</files>
  <action>
    Create TypedDict state schema (OrchestratorState) with fields for objective, subtasks, agent_assignments, findings, refinement_count, coverage_metrics, conflicts, and next_action.

    Implement PlanningOrchestrator class inheriting from BaseAgent, with initialization of LangGraph StateGraph. Add analyze_objective method that decomposes objectives into subtasks using Gemini API. Use structured output (JSON) for subtask generation.

    Avoid creating the full graph compilation yet - that comes in task 2. Focus on the foundation: state schema, class structure, and objective analysis.
  </action>
  <verify>python -c "from osint_system.orchestration.state_schemas import OrchestratorState; from osint_system.agents.planning_agent import PlanningOrchestrator; print('Imports successful')"</verify>
  <done>State schema defined, PlanningOrchestrator class exists with analyze_objective method</done>
</task>

<task type="auto">
  <name>Task 2: Implement adaptive routing with StateGraph</name>
  <files>osint_system/agents/planning_agent.py</files>
  <action>
    Complete the PlanningOrchestrator by implementing the _build_graph method using LangGraph StateGraph. Add nodes for: analyze_objective, assign_agents, coordinate_execution, evaluate_findings.

    Implement evaluate_findings with adaptive routing logic based on signal strength and coverage metrics. Add conditional edges that route to "explore", "refine", "synthesize", or "end" based on findings analysis.

    Use MemorySaver for in-memory checkpointing. Integrate with existing AgentRegistry and MessageBus from Phase 2.
  </action>
  <verify>python -c "from osint_system.agents.planning_agent import PlanningOrchestrator; p = PlanningOrchestrator(registry=None, message_bus=None); print('Graph built' if hasattr(p, 'graph') else 'Missing graph')"</verify>
  <done>StateGraph built with adaptive routing, conditional edges configured, checkpointing enabled</done>
</task>

<task type="auto">
  <name>Task 3: Add transparency and testing</name>
  <files>osint_system/agents/planning_agent.py, tests/agents/test_planning_agent.py</files>
  <action>
    Add transparency features to PlanningOrchestrator: get_status method returning current state and reasoning, explain_routing method showing why certain agents were chosen.

    Create basic unit tests for: state schema validation, objective decomposition, adaptive routing logic. Mock Gemini API calls and focus on routing decision logic. Test that refinement_count limits prevent infinite loops.
  </action>
  <verify>uv run python -m pytest tests/agents/test_planning_agent.py -v</verify>
  <done>Transparency methods implemented, unit tests pass for core planning logic</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `uv run python -m pytest tests/agents/test_planning_agent.py` passes
- [ ] PlanningOrchestrator can decompose objectives into subtasks
- [ ] Adaptive routing works based on signal strength and coverage
- [ ] No import errors or circular dependencies
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- PlanningOrchestrator integrates with existing Phase 2 components
- Adaptive routing demonstrates dynamic behavior based on findings
- Transparency features show reasoning
</success_criteria>

<output>
After completion, create `.planning/phases/3-planning-orchestration/03-01-SUMMARY.md`:

# Phase 3 Plan 1: Core Planning Agent Summary

**Core PlanningOrchestrator with LangGraph StateGraph and adaptive routing implemented**

## Accomplishments

- State schema with refinement tracking
- Adaptive routing based on findings
- Objective decomposition capability

## Files Created/Modified

- `osint_system/orchestration/state_schemas.py` - TypedDict definitions
- `osint_system/agents/planning_agent.py` - Main orchestrator implementation
- `tests/agents/test_planning_agent.py` - Unit tests

## Decisions Made

[Key decisions and rationale]

## Issues Encountered

[Problems and resolutions]

## Next Step

Ready for 03-02-PLAN.md: Task Queue and Distribution System
</output>